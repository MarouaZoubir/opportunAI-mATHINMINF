import os
import logging
import json
from typing import Tuple, Dict, Any, Optional
from vertexai.generative_models import GenerativeModel
from transformers import AutoTokenizer, AutoModelForCausalLM

logger = logging.getLogger(__name__)

class ModelService:
    """
    A service class to interact with AI models for generating
    explanations and visualizations.
    """
    
    def __init__(self, use_placeholder=False):
        """
        Initialize the model service.
        
        Args:
            use_placeholder (bool): If True, use placeholder responses instead
                                   of actual API calls (for development)
        """
        self.use_placeholder = use_placeholder
        if not use_placeholder:
            self.gemini_model = GenerativeModel(model_name="gemini-flash-1.5-math-qa")
            self.tokenizer = AutoTokenizer.from_pretrained("./codegen_model/")
            self.codegen_model = AutoModelForCausalLM.from_pretrained("./codegen_model/")
        
    def generate_explanation(self, prompt: str) -> str:
        """
        Generate a natural language explanation of a mathematical concept.
        
        Args:
            prompt (str): The user's mathematical query
            
        Returns:
            str: A markdown-formatted explanation
        """
        if self.use_placeholder:
            return self._get_placeholder_explanation(prompt)
        
        try:
            response = self.gemini_model.generate_content(
                f"Explain the following mathematical concept in detail: {prompt}. " + 
                "Use markdown formatting with clear headings, examples, and formulas."
            )
            return response.text
        except Exception as e:
            logger.error(f"Error calling Gemini API: {str(e)}")
            return self._get_placeholder_explanation(prompt)
    
    def generate_manim_code(self, prompt: str) -> str:
        """
        Generate Manim code to visualize a mathematical concept.
        
        Args:
            prompt (str): The user's mathematical query
            
        Returns:
            str: Python code using the Manim library
        """
        if self.use_placeholder:
            return self._get_placeholder_manim(prompt)
        
        try:
            input_text = f"Generate Manim code to visualize this mathematical concept: {prompt}"
            inputs = self.tokenizer(input_text, return_tensors="pt")
            outputs = self.codegen_model.generate(**inputs, max_new_tokens=1000)
            return self.tokenizer.decode(outputs[0], skip_special_tokens=True)
        except Exception as e:
            logger.error(f"Error calling CodeGen model: {str(e)}")
            return self._get_placeholder_manim(prompt)
    
    def _get_placeholder_explanation(self, prompt: str) -> str:
        """Get a placeholder explanation based on the prompt."""
        # Load explanation templates from a JSON file if it exists
        explanations_file = os.path.join(os.path.dirname(__file__), "explanation_templates.json")
        
        try:
            if os.path.exists(explanations_file):
                with open(explanations_file, 'r') as f:
                    templates = json.load(f)
                
                # Try to find a matching template based on keywords
                for keyword, content in templates.items():
                    if keyword.lower() in prompt.lower():
                        return content
            
            # Default placeholder if no match found
            return f"""
# {prompt.capitalize()}

This is a placeholder explanation for the mathematical concept you asked about. 
In a production environment, this would be generated by a fine-tuned Gemini AI model 
specifically trained on mathematical concepts.

The explanation would include:
- Clear definitions
- Key properties and formulas
- Visual interpretations
- Practical applications
- Common misconceptions

The corresponding visualization demonstrates the key concepts visually to enhance understanding.
"""
        except Exception as e:
            logger.error(f"Error loading explanation templates: {str(e)}")
            return f"Placeholder explanation for: {prompt}"
    
    def _get_placeholder_manim(self, prompt: str) -> str:
        """Get placeholder Manim code based on the prompt."""
        # Common Manim code that visualizes a simple mathematical concept
        return """from manim import *

class MathConcept(Scene):
    def construct(self):
        # Set up the scene
        title = Text("Mathematical Visualization", font_size=40)
        title.to_edge(UP)
        self.play(Write(title))
        self.wait()
        
        # Create a simple formula
        formula = MathTex(r"f(x) = \\sin(x) \\cdot e^{-\\frac{x^2}{10}}")
        self.play(Write(formula))
        self.wait()
        
        # Graph the function
        axes = Axes(
            x_range=[-5, 5, 1],
            y_range=[-1, 1, 0.2],
            axis_config={"include_tip": False}
        )
        
        graph = axes.plot(
            lambda x: np.sin(x) * np.exp(-x**2/10),
            color=BLUE
        )
        
        graph_group = VGroup(axes, graph)
        graph_group.scale(0.7)
        
        self.play(
            ReplacementTransform(formula, graph_group)
        )
        self.wait()
        
        # Add labels and annotations
        x_label = axes.get_x_axis_label("x")
        y_label = axes.get_y_axis_label("f(x)")
        
        self.play(
            Write(x_label),
            Write(y_label)
        )
        
        # Show points of interest
        dot1 = Dot(axes.c2p(0, 0), color=RED)
        dot2 = Dot(axes.c2p(np.pi/2, np.exp(-np.pi**2/40)), color=RED)
        
        self.play(
            Create(dot1),
            Create(dot2)
        )
        
        annotation1 = Text("Origin", font_size=20).next_to(dot1, DOWN)
        annotation2 = Text("Maximum", font_size=20).next_to(dot2, UP)
        
        self.play(
            Write(annotation1),
            Write(annotation2)
        )
        
        self.wait(2)
"""